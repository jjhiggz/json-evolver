{"version":3,"sources":["../src/index.ts","../src/zod-migration.ts","../src/mutators.ts"],"sourcesContent":["import {\n  ZodMigrations,\n  createJsonEvolver,\n  schemaEvolutionCountTag,\n  testAllVersions,\n  versionTag,\n} from \"./zod-migration\";\n\nimport { mutators } from \"./mutators\";\n\nexport {\n  ZodMigrations,\n  createJsonEvolver,\n  schemaEvolutionCountTag,\n  testAllVersions,\n  versionTag,\n  mutators,\n};\n","/* eslint-disable @typescript-eslint/ban-ts-comment */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { z, ZodSchema } from \"zod\";\nimport type { FillableObject, Mutator } from \"./types/types\";\nimport { mutators } from \"./mutators\";\nimport type { ObjectWith } from \"./types/ObjectWith\";\nimport type { Simplify } from \"type-fest\";\n\nexport const schemaEvolutionCountTag = \"__zod_migration_schema_evolution_count\";\nexport const versionTag = \"__zod_migration_version\";\n\nexport class ZodMigrations<Shape extends FillableObject> {\n  /**\n   * The amount of evolutions the schema has had since the beginning\n   */\n  private schemaEvolutionCount: number;\n\n  /**\n   * The transforms for this schema\n   */\n  private mutators: Mutator<any, any>[] = [];\n\n  /**\n   * The paths that are registered according to your schema count\n   */\n  private paths: string[] = [];\n\n  /**\n   * An array of tuples of the registered nested paths\n   */\n  private nestedPaths: [keyof Shape, ZodMigrations<any>][] = [];\n\n  /**\n   * A map of all the versions. Each version maps to a `schemaEvolutionCount` so that way we\n   * know which ones to skip per version\n   */\n  private versions: Map<number, number> = new Map();\n\n  /**\n   * For use in testing to see how many transforms were applied to generate the schema\n   */\n  private transformsAppliedCount: number = 0;\n\n  /**\n   * You probably don't need to use this but it's important internally to create new instances\n   */\n  constructor(input?: {\n    schemaEvolutionCount: number;\n    mutators: Mutator<any, any>[];\n    nestedPaths: [keyof Shape, ZodMigrations<any>][];\n    paths: string[];\n    versions: Map<number, number>;\n  }) {\n    if (input) {\n      const { schemaEvolutionCount = 1, mutators: mutators, paths } = input;\n      this.schemaEvolutionCount = schemaEvolutionCount;\n      this.mutators = mutators;\n      this.nestedPaths = input.nestedPaths;\n      this.paths = paths;\n      this.versions = input.versions;\n    } else {\n      this.mutators = [];\n      this.schemaEvolutionCount = 0;\n      this.nestedPaths = [];\n      this.paths = [];\n      this.versions = new Map();\n      this.transformsAppliedCount = 0;\n    }\n  }\n\n  /**\n   * Returns the next instance in the chain... See [Fluent Interfaces](https://en.wikipedia.org/wiki/Fluent_interface)\n   */\n  next = <NewShape extends FillableObject>() => {\n    return new ZodMigrations<NewShape>({\n      schemaEvolutionCount: this.schemaEvolutionCount + 1,\n      mutators: this.mutators,\n      // @ts-ignore\n      nestedPaths: this.nestedPaths,\n      paths: this.paths,\n      versions: this.versions,\n    });\n  };\n\n  /**\n   * Adds a key to your schema\n   */\n  add = <S extends ZodSchema, Path extends string>({\n    path,\n    schema,\n    defaultVal,\n  }: {\n    path: Path;\n    defaultVal: z.infer<S>;\n    schema: S;\n  }) => {\n    return this.mutate<Shape & ObjectWith<Path, z.infer<S>>>(() =>\n      // @ts-ignore\n      mutators.add({ path, schema, defaultVal })\n    );\n  };\n\n  /**\n   * Renames a key in your schema\n   */\n  rename = <SourceKey extends keyof Shape, DestinationKey extends string>({\n    source,\n    destination,\n  }: {\n    source: SourceKey;\n    destination: DestinationKey;\n  }) => {\n    return this.mutate(() => mutators.rename(source, destination));\n  };\n\n  /**\n   * Removes a key from your schema\n   */\n  remove = <SourceKey extends keyof Shape>(source: SourceKey) => {\n    this.paths = this.paths.filter((pathName) => pathName !== source);\n\n    return this.mutate(() => mutators.removeOne(source));\n  };\n\n  mutate = <T extends object>(\n    createMutator: (_input: Shape) => Mutator<Shape, T>\n  ) => {\n    const mutator = createMutator(undefined as any as Shape);\n    mutator.beforeMutate({\n      paths: this.paths,\n    });\n\n    this.paths = mutator.rewritePaths(this.paths);\n\n    this.mutators.push(mutator);\n\n    return this.next<T>() as ZodMigrations<T>;\n  };\n\n  /**\n   * Transform any previous version of your data into the most modern form\n   */\n  transform = (input: any): Shape => {\n    const zevoVersion = input[schemaEvolutionCountTag] ?? 0;\n\n    const firstInvalidMutationIndex = (() => {\n      if (zevoVersion) return 0;\n      return this.mutators.findIndex((mutator) => {\n        return !mutator.isValid(input);\n      });\n    })();\n\n    if (firstInvalidMutationIndex === -1 && !zevoVersion) return input;\n\n    const mutators = zevoVersion\n      ? this.mutators.slice(zevoVersion)\n      : this.mutators.slice(firstInvalidMutationIndex);\n\n    for (const mutator of mutators) {\n      this.transformsAppliedCount = this.transformsAppliedCount + 1;\n      input = mutator.up(input);\n    }\n    return input;\n  };\n\n  /**\n   * register a nested schema\n   */\n  register = <T extends FillableObject>(\n    key: keyof Shape,\n    jsonEvolution: ZodMigrations<T>\n  ) => {\n    this.nestedPaths.push([key, jsonEvolution]);\n    return this.next<Shape>();\n  };\n\n  /**\n   * stringify your schema for when you store it in your database\n   */\n  stringify = (rawInput: any, path: string[] = []): any => {\n    const input = structuredClone(rawInput);\n\n    if (Array.isArray(input)) {\n      return input.map((val) => this.stringify(val, [...path]));\n    }\n\n    if (Object(input) === input) {\n      const registeredPath = this.nestedPaths.find(\n        (nestedPath) => nestedPath[0] === path.join(\"/\")\n      );\n      const entries = Object.entries(input).map(([key, value]) => {\n        return [key, this.stringify(value, [...path, key])];\n      });\n\n      const fullObject = Object.fromEntries([...entries]);\n\n      if (path.length === 0) {\n        fullObject[schemaEvolutionCountTag] = this.schemaEvolutionCount;\n        return JSON.stringify(fullObject, null, 2);\n      } else if (registeredPath) {\n        fullObject[schemaEvolutionCountTag] =\n          registeredPath[1].schemaEvolutionCount;\n        return fullObject;\n      }\n    }\n\n    return input;\n  };\n\n  /**\n   * release a version of your schema\n   */\n  releaseVersion = (version: number) => {\n    const maxVersion = Math.max(...this.versions.keys());\n\n    if (version < maxVersion) {\n      throw new Error(`Please use a version greater than ${maxVersion}`);\n    }\n\n    this.versions = this.versions.set(version, this.schemaEvolutionCount);\n\n    return this;\n  };\n\n  __get_private_data() {\n    return {\n      schemaEvolutionCount: this.schemaEvolutionCount,\n      mutators: this.mutators,\n      paths: this.paths,\n      nestedPaths: this.nestedPaths,\n      versions: this.versions,\n      transformsAppliedCount: this.transformsAppliedCount,\n    };\n  }\n\n  /**\n   * create a safe schema from a strict schema\n   */\n  safeSchema = <Z extends ZodSchema<Simplify<Shape>, any, any>>(\n    schema: Z\n  ): Simplify<Shape> extends z.infer<Z> ? Z : never => {\n    // @ts-ignore\n    return z.preprocess(\n      this.transform,\n      (schema as any).passthrough() as typeof schema\n    );\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const createJsonEvolver = <T extends object>(_input: {\n  schema: ZodSchema<T>;\n}) => {\n  return new ZodMigrations<T>();\n};\n\n/***\n  It's not a perfect test but it at least let's you know if your data will become the valid shape\n  Technically we need to check that appropriate data is preserved as well\n */\nexport const testAllVersions = ({\n  evolver,\n  schema,\n  expect,\n  startData,\n  customTestCase = [],\n}: {\n  evolver: ZodMigrations<any>;\n  schema: ZodSchema;\n  expect: (input: any) => any;\n  startData: any;\n  customTestCase?: { input: any; output: any }[];\n}) => {\n  const metaData = evolver.__get_private_data();\n\n  const safeSchema = evolver.safeSchema(schema);\n\n  const checkSchema = (input: any) => {\n    const result = safeSchema.safeParse(input).success;\n    if (!result) console.log(`invalid input checkSchema`, input);\n    expect(result).toBe(true);\n  };\n\n  const checkValidOutput = ([input, output]: [any, any]) => {\n    const result = safeSchema.parse(input);\n    if (!result) console.log(`invalid input`, input, `for output`, output);\n    expect(result).toEqual(output);\n  };\n\n  checkSchema(startData);\n  let currentData = startData;\n\n  for (const mutator of metaData.mutators) {\n    currentData = mutator.up(currentData);\n    checkSchema(currentData);\n  }\n\n  for (const testCase of customTestCase) {\n    checkValidOutput([testCase.input, testCase.output]);\n  }\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport { z, type AnyZodObject, type ZodSchema } from \"zod\";\nimport type {\n  FillableObject,\n  Mutator,\n  NonMergeObject,\n  RenameManyReturn,\n} from \"./types/types\";\nimport { addProp, mapKeys, merge, omit, pipe, unique } from \"remeda\";\n\nconst isValid = (input: any, zodSchema: AnyZodObject) =>\n  zodSchema.safeParse(input).success;\n\nconst add = <\n  Shape extends FillableObject,\n  Schema extends ZodSchema,\n  Path extends string\n>({\n  path,\n  schema,\n  defaultVal,\n}: {\n  path: Path;\n  defaultVal: z.infer<Schema>;\n  schema: Schema;\n}) => {\n  const up = (input: Shape) => {\n    return addProp(input, path, defaultVal);\n  };\n\n  return {\n    tag: \"add\",\n    up,\n    // @ts-ignore\n    isValid: (input: unknown) => isValid(input?.[path], schema),\n    rewritePaths: (input) => [...input, path],\n    beforeMutate: ({ paths }) => {\n      if (paths.includes(path))\n        throw new Error(`'${path}' already exists in your JsonEvolver`);\n    },\n  } satisfies Mutator<Shape, ReturnType<typeof up>>;\n};\n\nconst removeOne = <Shape extends object, Path extends keyof Shape>(\n  path: Path\n) => {\n  const up = (input: Shape) => {\n    return omit(input, [path]);\n  };\n\n  return {\n    up,\n    tag: \"removeOne\",\n    isValid: (input) => !(path in input),\n    rewritePaths: (input) =>\n      input.filter((pathInEvolver) => pathInEvolver !== path),\n    beforeMutate: () => {\n      // do nothing, inputs parsed in typesystem\n    },\n  } satisfies Mutator<Shape, ReturnType<typeof up>>;\n};\n\nconst removeMany = <Shape extends object, K extends keyof Shape>(\n  paths: ReadonlyArray<K>\n) => {\n  const up = (input: Shape) => {\n    return omit(input, paths);\n  };\n\n  return {\n    tag: \"removeMany\",\n    up,\n    isValid: () => false,\n    beforeMutate: () => {\n      // do nothing, inputs parsed in typesystem\n    },\n    rewritePaths: (input) =>\n      input.filter((pathInEvolver) => !paths.includes(pathInEvolver as any)),\n  } satisfies Mutator<Shape, ReturnType<typeof up>>;\n};\n\nconst rename = <\n  Shape extends object,\n  SourceKey extends keyof Shape,\n  Destination extends string\n>(\n  source: SourceKey,\n  destination: Destination\n) => {\n  const up = (input: Shape) => {\n    const value = input[source];\n    return pipe(input, omit([source]), addProp(destination, value));\n  };\n\n  return {\n    up,\n    tag: \"rename\",\n    // @ts-ignore\n    isValid: (input) => destination in input && !(source in input),\n    beforeMutate: ({ paths }) => {\n      if (paths.includes(destination)) {\n        // @ts-ignore\n        throw new Error(\n          `Cannot rename '${\n            source as string\n          }' to  '${destination}' because it already exists in your schema`\n        );\n      }\n    },\n    rewritePaths: (paths) => {\n      return [...paths, destination].filter((p) => p !== source);\n    },\n  } satisfies Mutator<Shape, ReturnType<typeof up>>;\n};\n\nconst addMany = <\n  Shape extends FillableObject,\n  Schema extends ZodSchema<NonMergeObject<Shape>, any, any>\n>({\n  defaultValues,\n  schema,\n}: {\n  defaultValues: z.infer<Schema>;\n  schema: Schema;\n}) => {\n  const up = (input: Shape) => {\n    return merge(input, defaultValues);\n  };\n\n  return {\n    tag: \"addMany\",\n    up,\n    isValid: (input) => {\n      const entries = Object.entries((schema as any).shape);\n      entries.every((entry) => {\n        const key = entry[0];\n        const schema = entry[1];\n        // @ts-ignore\n        return schema?.safeParse(input?.[key]).success;\n      });\n      return false;\n    },\n    beforeMutate: () => {\n      // Do nothing, should be accounted for\n    },\n    // @ts-ignore\n    rewritePaths: (paths) => [...paths, ...Object.keys(schema.shape)],\n  } satisfies Mutator<Shape, ReturnType<typeof up>>;\n};\n\nconst renameMany = <\n  Shape extends FillableObject,\n  Renames extends Partial<Readonly<Record<keyof Shape, string>>>\n>({\n  renames,\n}: {\n  renames: Renames;\n}) => {\n  const up = (input: Shape) => {\n    const result = mapKeys(input, (key) => {\n      // @ts-ignore\n      return key in renames ? renames[key as any] : key;\n    }) as RenameManyReturn<Shape, Renames>;\n\n    return result;\n  };\n\n  return {\n    tag: \"renameMany\",\n    up,\n    isValid: (input) => {\n      return Object.entries(renames).every(([source, destination]) => {\n        return (\n          (destination as keyof typeof input) in input && !(source in input)\n        );\n      });\n    },\n    beforeMutate: () => {\n      if (unique(Object.values(rename)).length > Object.values(rename).length) {\n        throw new Error(\"Cannot do multiple renames to the same value\");\n      }\n      Object.values(rename).forEach((destinationKey) => {\n        Object.keys(rename).forEach((sourceKey) => {\n          if (sourceKey === destinationKey) {\n            throw new Error(\n              `Cannot set source ${sourceKey} to destination ${destinationKey} in one migration`\n            );\n          }\n        });\n      });\n      // Do nothing, should be accounted for\n    },\n    rewritePaths: (paths) => {\n      const values = Object.values(renames) as string[];\n      return [...paths, ...values].filter((p) =>\n        Object.keys(renames).includes(p)\n      );\n    },\n  } satisfies Mutator<Shape, RenameManyReturn<Shape, Renames>>;\n};\n\nexport const mutators = {\n  add,\n  addMany,\n  removeOne,\n  removeMany,\n  rename,\n  renameMany,\n};\n"],"mappings":"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","names":["schema","mutators"]}